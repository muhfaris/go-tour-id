Method dan Interface
Pelajaran ini membahas method dan interface, konstruksi yang membuat objek dan perilakunya.

The Go Authors
https://golang.org

* Method

Go tidak memiliki class.
Namun, anda bisa mendefinisikan method pada tipe `struct`.

Untuk membuat fungsi untuk `struct`, tambahkan _method_receiver_ (instan dari `struct` atau tipe lain) di antara kata `func` dan nama method.

.play methods/methods.go

* Method lanjutan

Anda bisa mendeklarasikan method pada _setiap_ tipe yang dideklarasikan pada paket anda, tidak hanya pada tipe struct saja.

Namun, anda tidak bisa mendefinisikan sebuah method pada tipe dari paket lain (termasuk tipe buatan).

.play methods/methods-continued.go

* Method dengan pointer-receiver

Method dapat diasosiasikan dengan tipe bernama atau sebuah pointer terhadap tipe bernama.

Telah kita lihat dua method `Abs`.
Satu pada tipe pointer `*Vertex` dan yang lainnya pada tipe `MyFloat`.

Ada dua alasan kenapa menggunakan pointer-receiver.
Pertama, menghindari penyalinan disetiap pemanggilan fungsi (lebih efisien bila tipenya berupa struct yang besar).
Kedua, supaya method dapat mengubah nilai yang dirujuk.

Coba ubah deklarasi dari method `Abs` dan `Scale` menggunakan `Vertex` sebagai receiver, bukan `*Vertex`.

Method `Scale` tidak berpengaruh bila `v` adalah `Vertex`.
`Scale` mengubah `v`.
Saat `v` berupa tipe nilai (bukan pointer), method tersebut mendapat salinan dari `Vertex` dan tidak mengubah nilai aslinya.

`Abs` bekerja dengan cara sebaliknya.
Ia hanya membaca `v`.
Tidak masalah apakah ia membaca nilai aslinya (lewat pointer) atau nilai salinannya.

.play methods/methods-with-pointer-receivers.go

* Interface

Sebuah tipe interface didefinisikan oleh sekumpulan method.

Nilai dari tipe interface dapat menyimpan nilai apapun yang mengimplementasikan method tersebut.

*Catatan:* Terdapat kesalahan di contoh kode pada baris 22.
`Vertex` (tipe nilai) tidak memenuhi `Abser` karena method `Abs` hanya didefinisikan pada `*Vertex` (tipe pointer).

.play methods/interfaces.go

* Interface dipenuhi secara implisit

Sebuah tipe mengimplementasikan sebuah interface dengan mengimplementasikan method-methodnya.
Tidak ada deklarasi eksplisit; tidak ada perintah "implements".

Interface implisit memisahkan implementasi paket dari paket yang mendefinisikan interface tersebut: keduanya tidak memiliki kebergantungan.

Hal ini mendorong ketepatan pendefinisian interface, karena anda tidak perlu mencari setiap implementasi dan menandainya dengan nama interface yang baru.

[[https://golang.org/pkg/io/][Paket io]]
telah mendefinisikan `Reader` dan `Writer`; anda tidak perlu menambahkannya.

.play methods/interfaces-are-satisfied-implicitly.go

* Stringer

Interface yang ada dimanapun yaitu
[[//golang.org/pkg/fmt/#Stringer][`Stringer`]]
didefinisikan oleh paket
[[//golang.org/pkg/fmt/][`fmt`]].

	type Stringer interface {
		String() string
	}

Sebuah `Stringer` adalah suatu tipe yang mendeskripsikan dirinya sendiri sebagai string.
Paket `fmt` (dan banyak lainnya) menggunakan interface ini untuk mencetak nilai.

.play methods/stringer.go

* Latihan: Stringer

Buat tipe `IPAddr` yang mengimplementasikan `fmt.Stringer` untuk mencetak alamat dengan empat tanda titik.

Misalnya, `IPAddr{1,`2,`3,`4}` mengeluarkan `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Error

Program Go mengekspresikan keadaan error dengan nilai `error`.

Tipe `error` adalah interface buatan mirip dengan `fmt.Stringer`:

	type error interface {
		Error() string
	}

Seperti dengan `fmt.Stringer`, paket `fmt` mencari interface `error` saat mencetak nilai.

Fungsi terkadang mengembalikan nilai `error`, dan kode yang memanggilnya harus menangani error dengan memeriksa apakah error bernilai `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
		return
	}
	fmt.Println("Converted integer:", i)

`error` yang nil menandakan sukses; `error` yang bukan-nil menandakan adanya kesalahan.

.play methods/errors.go

* Latihan: Error

Salin fungsi `Sqrt` anda dari
[[/flowcontrol/8][latihan sebelumnya]]
dan ubah untuk mengembalikan nilai `error`.

`Sqrt` seharusnya mengembalikan nilai error bukan-nil saat diberikan angka negatif, karena tidak mendukung bilangan kompleks.

Buatlah tipe baru

	type ErrNegativeSqrt float64

dan buat dia sebagai `error` dengan memberikan method

	func (e ErrNegativeSqrt) Error() string

sehingga `ErrNegativeSqrt(-2).Error()` mengembalikan `"cannot`Sqrt`negative`number:`-2"`.

*Catatan:* pemanggilan `fmt.Sprint(e)` di dalam method `Error` akan membuat program berulang tak henti.
Anda dapat menghindari hal tersebut dengan mengkonversi `e`: `fmt.Sprint(float64(e))`.
_Kenapa?_

Ubah fungsi `Sqrt` mengembalikan nilai `ErrNegativeSqrt` saat diberikan nilai negatif.

.play methods/exercise-errors.go

* Reader

Paket `io` memiliki spesifikasi interface `io.Reader`, yang merepresentasikan berakhirnya pembacaan sebuah aliran data.

Standar pustaka Go memiliki
[[https://golang.org/search?q=Read#Global][banyak implementasi]]
dari interface tersebut, termasuk berkas, koneksi jaringan, kompresi, cipher, dll.

Interface `io.Reader` memiliki method `Read`:

	func (T) Read(b []byte) (n int, err error)

`Read` mengisi parameter slice byte dengan data dan mengembalikan jumlah byte yang diisi dan nilai errornya.
Ia mengembalikan error `io.EOF` saat aliran data berakhir.

Contoh kode membuat sebuah 
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
dan memproses 8 bytes keluarannya.

.play methods/reader.go

* Latihan: Reader

Implementasikan sebuah tipe `Reader` yang menghilangkan karakter ASCII `'A'` yang panjang.

.play methods/exercise-reader.go

* Latihan: rot13Reader

Pola umumnya adalah sebuah
[[https://golang.org/pkg/io/#Reader][io.Reader]]
yang membungkus `io.Reader` lainnya, memodifikasi aliran data dengan cara tertentu.

Sebagai contohnya, fungsi 
[[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]]
mengambil `io.Reader` (aliran data terkompres) dan mengembalikan `*gzip.Reader` yang juga mengimplementasikan `io.Reader` (aliran data tak-terkompres).

Implementasikan `rot13Reader` yang mengimplementasikan `io.Reader` dengan membaca dari `io.Reader`, modifikasi aliran data dengan menerapkan penyandian
[[https://en.wikipedia.org/wiki/ROT13][rot13]]
terhadap semua karakter alfabet.

Tipe `rot13Reader` telah disediakan untuk anda.
Buatlah ia menjadi `io.Reader` dengan mengimplementasikan method `Read`.

.play methods/exercise-rot-reader.go

* Server Web

[[https://golang.org/pkg/net/https/][Paket https]]
menyediakan permintaan HTTP menggunakan nilai apapun yang mengimplementasikan `http.Handler`:

	package https

	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

Pada contoh berikut, tipe `Hello` mengimplementasikan `http.Handler`.

Buka
[[https://localhost:4000/][https://localhost:4000/]]
untuk melihat hasilnya.

#appengine: *Catatan:* Contoh ini tidak akan berjalan lewat antarmuka tur berbasis web.
#appengine: Untuk mencoba server web anda harus
#appengine: [[https://golang.org/doc/install/][memasang Go]].

.play methods/web-servers.go

* Latihan: HTTP Handlers

Implementasikan tipe berikut dan definisikan method `ServeHTTP`.
Registrasikan mereka supaya dapat menangani _path_ tertentu di dalam server web anda.

	type String string

	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

Sebagai contohnya, anda bisa meregister handler menggunakan:

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

#appengine: *Catatan:* Contoh ini tidak akan berjalan lewat antarmuka tur berbasis web.
#appengine: Untuk mencoba server web anda harus
#appengine: [[https://golang.org/doc/install/][memasang Go]].

.play methods/exercise-https-handlers.go

* Gambar

[[https://golang.org/pkg/image/#Image][Paket image]]
mendefinisikan interface `Image`:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Catatan*: Nilai kembalian `Rectangle` dari method `Bounds` sebenarnya adalah deklarasi
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]]
yang telah ada di dalam paket `image`.

(Lihat
[[https://golang.org/pkg/image/#Image][dokumentasi untuk paket Image]]
untuk lebih jelas.)

Tipe `color.Color` dan `color.Model` juga interface, tapi kita akan menggunakan implementasi `color.RGBA` dan `color.RGBAModel`.
Interface dan tipe tersebut dispesifikasikan oleh 
[[https://golang.org/pkg/image/color/][paket image/color]].

.play methods/images.go

* Latihan: Gambar

Ingat generator gambar yang anda buat sebelumnya?
Mari kita buat satu lagi, tapi kali ini mengembalikan implementasi dari `image.Image` bukan sebuah slice dari data.

Definisikan tipe `Image` anda sendiri, kemudian implementasikan
[[https://golang.org/pkg/image/#Image][method-method yang dibutuhkan]]
, dan panggil `pic.ShowImage`.

`Bounds` seharusnya mengembalikan `image.Rectangle`, seperti `image.Rect(0,`0,`w,`h)`.

`ColorModel` seharusnya mengembalikan `color.RGBAModel`.

`At` seharusnya mengembalikan sebuah warna;
nilai `v` pada generator gambar berkoresponden dengan `color.RGBA{v,`v,`255,`255}`.

.play methods/exercise-images.go

* Selamat!

Anda telah menyelesaikan pelajaran ini!

Anda bisa kembali ke daftar
[[/list][modul]]
untuk melihat apa yang bisa dipelajari selanjutnya, atau meneruskan dengan
[[javascript:click(".next-page")][pelajaran selanjutnya]].
